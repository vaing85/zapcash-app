"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectSerializer = void 0;
__exportStar(require("./models"), exports);
const accelInfo_1 = require("./accelInfo");
const additionalCommission_1 = require("./additionalCommission");
const additionalSettings_1 = require("./additionalSettings");
const additionalSettingsResponse_1 = require("./additionalSettingsResponse");
const address_1 = require("./address");
const affirmInfo_1 = require("./affirmInfo");
const afterpayTouchInfo_1 = require("./afterpayTouchInfo");
const alipayPlusInfo_1 = require("./alipayPlusInfo");
const allowedOrigin_1 = require("./allowedOrigin");
const allowedOriginsResponse_1 = require("./allowedOriginsResponse");
const amexInfo_1 = require("./amexInfo");
const amount_1 = require("./amount");
const androidApp_1 = require("./androidApp");
const androidAppError_1 = require("./androidAppError");
const androidAppsResponse_1 = require("./androidAppsResponse");
const androidCertificate_1 = require("./androidCertificate");
const androidCertificatesResponse_1 = require("./androidCertificatesResponse");
const apiCredential_1 = require("./apiCredential");
const apiCredentialLinks_1 = require("./apiCredentialLinks");
const applePayInfo_1 = require("./applePayInfo");
const bcmcInfo_1 = require("./bcmcInfo");
const billingEntitiesResponse_1 = require("./billingEntitiesResponse");
const billingEntity_1 = require("./billingEntity");
const cardholderReceipt_1 = require("./cardholderReceipt");
const cartesBancairesInfo_1 = require("./cartesBancairesInfo");
const clearpayInfo_1 = require("./clearpayInfo");
const commission_1 = require("./commission");
const company_1 = require("./company");
const companyApiCredential_1 = require("./companyApiCredential");
const companyLinks_1 = require("./companyLinks");
const companyUser_1 = require("./companyUser");
const configuration_1 = require("./configuration");
const connectivity_1 = require("./connectivity");
const contact_1 = require("./contact");
const createAllowedOriginRequest_1 = require("./createAllowedOriginRequest");
const createApiCredentialResponse_1 = require("./createApiCredentialResponse");
const createCompanyApiCredentialRequest_1 = require("./createCompanyApiCredentialRequest");
const createCompanyApiCredentialResponse_1 = require("./createCompanyApiCredentialResponse");
const createCompanyUserRequest_1 = require("./createCompanyUserRequest");
const createCompanyUserResponse_1 = require("./createCompanyUserResponse");
const createCompanyWebhookRequest_1 = require("./createCompanyWebhookRequest");
const createMerchantApiCredentialRequest_1 = require("./createMerchantApiCredentialRequest");
const createMerchantRequest_1 = require("./createMerchantRequest");
const createMerchantResponse_1 = require("./createMerchantResponse");
const createMerchantUserRequest_1 = require("./createMerchantUserRequest");
const createMerchantWebhookRequest_1 = require("./createMerchantWebhookRequest");
const createUserResponse_1 = require("./createUserResponse");
const currency_1 = require("./currency");
const customNotification_1 = require("./customNotification");
const dataCenter_1 = require("./dataCenter");
const dinersInfo_1 = require("./dinersInfo");
const eventUrl_1 = require("./eventUrl");
const externalTerminalAction_1 = require("./externalTerminalAction");
const generateApiKeyResponse_1 = require("./generateApiKeyResponse");
const generateClientKeyResponse_1 = require("./generateClientKeyResponse");
const generateHmacKeyResponse_1 = require("./generateHmacKeyResponse");
const genericPmWithTdiInfo_1 = require("./genericPmWithTdiInfo");
const googlePayInfo_1 = require("./googlePayInfo");
const gratuity_1 = require("./gratuity");
const hardware_1 = require("./hardware");
const idName_1 = require("./idName");
const installAndroidAppDetails_1 = require("./installAndroidAppDetails");
const installAndroidCertificateDetails_1 = require("./installAndroidCertificateDetails");
const invalidField_1 = require("./invalidField");
const jCBInfo_1 = require("./jCBInfo");
const key_1 = require("./key");
const klarnaInfo_1 = require("./klarnaInfo");
const links_1 = require("./links");
const linksElement_1 = require("./linksElement");
const listCompanyApiCredentialsResponse_1 = require("./listCompanyApiCredentialsResponse");
const listCompanyResponse_1 = require("./listCompanyResponse");
const listCompanyUsersResponse_1 = require("./listCompanyUsersResponse");
const listExternalTerminalActionsResponse_1 = require("./listExternalTerminalActionsResponse");
const listMerchantApiCredentialsResponse_1 = require("./listMerchantApiCredentialsResponse");
const listMerchantResponse_1 = require("./listMerchantResponse");
const listMerchantUsersResponse_1 = require("./listMerchantUsersResponse");
const listStoresResponse_1 = require("./listStoresResponse");
const listTerminalsResponse_1 = require("./listTerminalsResponse");
const listWebhooksResponse_1 = require("./listWebhooksResponse");
const localization_1 = require("./localization");
const logo_1 = require("./logo");
const meApiCredential_1 = require("./meApiCredential");
const mealVoucherFRInfo_1 = require("./mealVoucherFRInfo");
const merchant_1 = require("./merchant");
const merchantLinks_1 = require("./merchantLinks");
const minorUnitsMonetaryValue_1 = require("./minorUnitsMonetaryValue");
const modelFile_1 = require("./modelFile");
const name_1 = require("./name");
const name2_1 = require("./name2");
const nexo_1 = require("./nexo");
const notification_1 = require("./notification");
const notificationUrl_1 = require("./notificationUrl");
const nyceInfo_1 = require("./nyceInfo");
const offlineProcessing_1 = require("./offlineProcessing");
const opi_1 = require("./opi");
const orderItem_1 = require("./orderItem");
const paginationLinks_1 = require("./paginationLinks");
const passcodes_1 = require("./passcodes");
const payAtTable_1 = require("./payAtTable");
const payByBankPlaidInfo_1 = require("./payByBankPlaidInfo");
const payMeInfo_1 = require("./payMeInfo");
const payPalInfo_1 = require("./payPalInfo");
const payToInfo_1 = require("./payToInfo");
const payment_1 = require("./payment");
const paymentMethod_1 = require("./paymentMethod");
const paymentMethodResponse_1 = require("./paymentMethodResponse");
const paymentMethodSetupInfo_1 = require("./paymentMethodSetupInfo");
const payoutSettings_1 = require("./payoutSettings");
const payoutSettingsRequest_1 = require("./payoutSettingsRequest");
const payoutSettingsResponse_1 = require("./payoutSettingsResponse");
const profile_1 = require("./profile");
const pulseInfo_1 = require("./pulseInfo");
const receiptOptions_1 = require("./receiptOptions");
const receiptPrinting_1 = require("./receiptPrinting");
const referenced_1 = require("./referenced");
const refunds_1 = require("./refunds");
const releaseUpdateDetails_1 = require("./releaseUpdateDetails");
const reprocessAndroidAppResponse_1 = require("./reprocessAndroidAppResponse");
const requestActivationResponse_1 = require("./requestActivationResponse");
const restServiceError_1 = require("./restServiceError");
const scheduleTerminalActionsRequest_1 = require("./scheduleTerminalActionsRequest");
const scheduleTerminalActionsRequestActionDetails_1 = require("./scheduleTerminalActionsRequestActionDetails");
const scheduleTerminalActionsResponse_1 = require("./scheduleTerminalActionsResponse");
const sepaDirectDebitInfo_1 = require("./sepaDirectDebitInfo");
const settings_1 = require("./settings");
const shippingLocation_1 = require("./shippingLocation");
const shippingLocationsResponse_1 = require("./shippingLocationsResponse");
const signature_1 = require("./signature");
const sodexoInfo_1 = require("./sodexoInfo");
const sofortInfo_1 = require("./sofortInfo");
const splitConfiguration_1 = require("./splitConfiguration");
const splitConfigurationList_1 = require("./splitConfigurationList");
const splitConfigurationLogic_1 = require("./splitConfigurationLogic");
const splitConfigurationRule_1 = require("./splitConfigurationRule");
const standalone_1 = require("./standalone");
const starInfo_1 = require("./starInfo");
const store_1 = require("./store");
const storeAndForward_1 = require("./storeAndForward");
const storeCreationRequest_1 = require("./storeCreationRequest");
const storeCreationWithMerchantCodeRequest_1 = require("./storeCreationWithMerchantCodeRequest");
const storeLocation_1 = require("./storeLocation");
const storeSplitConfiguration_1 = require("./storeSplitConfiguration");
const subMerchantData_1 = require("./subMerchantData");
const supportedCardTypes_1 = require("./supportedCardTypes");
const surcharge_1 = require("./surcharge");
const swishInfo_1 = require("./swishInfo");
const tapToPay_1 = require("./tapToPay");
const terminal_1 = require("./terminal");
const terminalActionScheduleDetail_1 = require("./terminalActionScheduleDetail");
const terminalAssignment_1 = require("./terminalAssignment");
const terminalConnectivity_1 = require("./terminalConnectivity");
const terminalConnectivityBluetooth_1 = require("./terminalConnectivityBluetooth");
const terminalConnectivityCellular_1 = require("./terminalConnectivityCellular");
const terminalConnectivityEthernet_1 = require("./terminalConnectivityEthernet");
const terminalConnectivityWifi_1 = require("./terminalConnectivityWifi");
const terminalInstructions_1 = require("./terminalInstructions");
const terminalModelsResponse_1 = require("./terminalModelsResponse");
const terminalOrder_1 = require("./terminalOrder");
const terminalOrderRequest_1 = require("./terminalOrderRequest");
const terminalOrdersResponse_1 = require("./terminalOrdersResponse");
const terminalProduct_1 = require("./terminalProduct");
const terminalProductPrice_1 = require("./terminalProductPrice");
const terminalProductsResponse_1 = require("./terminalProductsResponse");
const terminalReassignmentRequest_1 = require("./terminalReassignmentRequest");
const terminalReassignmentTarget_1 = require("./terminalReassignmentTarget");
const terminalSettings_1 = require("./terminalSettings");
const testCompanyWebhookRequest_1 = require("./testCompanyWebhookRequest");
const testOutput_1 = require("./testOutput");
const testWebhookRequest_1 = require("./testWebhookRequest");
const testWebhookResponse_1 = require("./testWebhookResponse");
const ticketInfo_1 = require("./ticketInfo");
const timeouts_1 = require("./timeouts");
const transactionDescriptionInfo_1 = require("./transactionDescriptionInfo");
const twintInfo_1 = require("./twintInfo");
const uninstallAndroidAppDetails_1 = require("./uninstallAndroidAppDetails");
const uninstallAndroidCertificateDetails_1 = require("./uninstallAndroidCertificateDetails");
const updatableAddress_1 = require("./updatableAddress");
const updateCompanyApiCredentialRequest_1 = require("./updateCompanyApiCredentialRequest");
const updateCompanyUserRequest_1 = require("./updateCompanyUserRequest");
const updateCompanyWebhookRequest_1 = require("./updateCompanyWebhookRequest");
const updateMerchantApiCredentialRequest_1 = require("./updateMerchantApiCredentialRequest");
const updateMerchantUserRequest_1 = require("./updateMerchantUserRequest");
const updateMerchantWebhookRequest_1 = require("./updateMerchantWebhookRequest");
const updatePaymentMethodInfo_1 = require("./updatePaymentMethodInfo");
const updatePayoutSettingsRequest_1 = require("./updatePayoutSettingsRequest");
const updateSplitConfigurationLogicRequest_1 = require("./updateSplitConfigurationLogicRequest");
const updateSplitConfigurationRequest_1 = require("./updateSplitConfigurationRequest");
const updateSplitConfigurationRuleRequest_1 = require("./updateSplitConfigurationRuleRequest");
const updateStoreRequest_1 = require("./updateStoreRequest");
const uploadAndroidAppResponse_1 = require("./uploadAndroidAppResponse");
const uploadAndroidCertificateResponse_1 = require("./uploadAndroidCertificateResponse");
const url_1 = require("./url");
const user_1 = require("./user");
const vippsInfo_1 = require("./vippsInfo");
const weChatPayInfo_1 = require("./weChatPayInfo");
const weChatPayPosInfo_1 = require("./weChatPayPosInfo");
const webhook_1 = require("./webhook");
const webhookLinks_1 = require("./webhookLinks");
const wifiProfiles_1 = require("./wifiProfiles");
/* tslint:disable:no-unused-variable */
let primitives = [
    "string",
    "boolean",
    "double",
    "integer",
    "long",
    "float",
    "number",
    "any"
];
let enumsMap = new Set([
    "AccelInfo.ProcessingTypeEnum",
    "AmexInfo.ServiceLevelEnum",
    "AndroidApp.StatusEnum",
    "Connectivity.SimcardStatusEnum",
    "CreateCompanyWebhookRequest.CommunicationFormatEnum",
    "CreateCompanyWebhookRequest.EncryptionProtocolEnum",
    "CreateCompanyWebhookRequest.FilterMerchantAccountTypeEnum",
    "CreateCompanyWebhookRequest.NetworkTypeEnum",
    "CreateMerchantWebhookRequest.CommunicationFormatEnum",
    "CreateMerchantWebhookRequest.EncryptionProtocolEnum",
    "CreateMerchantWebhookRequest.NetworkTypeEnum",
    "DinersInfo.ServiceLevelEnum",
    "InstallAndroidAppDetails.TypeEnum",
    "InstallAndroidCertificateDetails.TypeEnum",
    "JCBInfo.ServiceLevelEnum",
    "KlarnaInfo.RegionEnum",
    "Notification.CategoryEnum",
    "NyceInfo.ProcessingTypeEnum",
    "PayAtTable.AuthenticationMethodEnum",
    "PayAtTable.PaymentInstrumentEnum",
    "PaymentMethod.VerificationStatusEnum",
    "PaymentMethodResponse.TypesWithErrorsEnum",
    "PaymentMethodSetupInfo.ShopperInteractionEnum",
    "PaymentMethodSetupInfo.TypeEnum",
    "PayoutSettings.PriorityEnum",
    "PayoutSettings.VerificationStatusEnum",
    "PulseInfo.ProcessingTypeEnum",
    "ReleaseUpdateDetails.TypeEnum",
    "ScheduleTerminalActionsRequestActionDetails.TypeEnum",
    "SplitConfigurationLogic.AcquiringFeesEnum",
    "SplitConfigurationLogic.AdyenCommissionEnum",
    "SplitConfigurationLogic.AdyenFeesEnum",
    "SplitConfigurationLogic.AdyenMarkupEnum",
    "SplitConfigurationLogic.ChargebackEnum",
    "SplitConfigurationLogic.ChargebackCostAllocationEnum",
    "SplitConfigurationLogic.InterchangeEnum",
    "SplitConfigurationLogic.PaymentFeeEnum",
    "SplitConfigurationLogic.RefundEnum",
    "SplitConfigurationLogic.RefundCostAllocationEnum",
    "SplitConfigurationLogic.RemainderEnum",
    "SplitConfigurationLogic.SchemeFeeEnum",
    "SplitConfigurationLogic.SurchargeEnum",
    "SplitConfigurationLogic.TipEnum",
    "SplitConfigurationRule.FundingSourceEnum",
    "SplitConfigurationRule.ShopperInteractionEnum",
    "StarInfo.ProcessingTypeEnum",
    "Store.StatusEnum",
    "TerminalAssignment.StatusEnum",
    "TerminalConnectivityCellular.StatusEnum",
    "TransactionDescriptionInfo.TypeEnum",
    "UninstallAndroidAppDetails.TypeEnum",
    "UninstallAndroidCertificateDetails.TypeEnum",
    "UpdateCompanyWebhookRequest.CommunicationFormatEnum",
    "UpdateCompanyWebhookRequest.EncryptionProtocolEnum",
    "UpdateCompanyWebhookRequest.FilterMerchantAccountTypeEnum",
    "UpdateCompanyWebhookRequest.NetworkTypeEnum",
    "UpdateMerchantWebhookRequest.CommunicationFormatEnum",
    "UpdateMerchantWebhookRequest.EncryptionProtocolEnum",
    "UpdateMerchantWebhookRequest.NetworkTypeEnum",
    "UpdateSplitConfigurationLogicRequest.AcquiringFeesEnum",
    "UpdateSplitConfigurationLogicRequest.AdyenCommissionEnum",
    "UpdateSplitConfigurationLogicRequest.AdyenFeesEnum",
    "UpdateSplitConfigurationLogicRequest.AdyenMarkupEnum",
    "UpdateSplitConfigurationLogicRequest.ChargebackEnum",
    "UpdateSplitConfigurationLogicRequest.ChargebackCostAllocationEnum",
    "UpdateSplitConfigurationLogicRequest.InterchangeEnum",
    "UpdateSplitConfigurationLogicRequest.PaymentFeeEnum",
    "UpdateSplitConfigurationLogicRequest.RefundEnum",
    "UpdateSplitConfigurationLogicRequest.RefundCostAllocationEnum",
    "UpdateSplitConfigurationLogicRequest.RemainderEnum",
    "UpdateSplitConfigurationLogicRequest.SchemeFeeEnum",
    "UpdateSplitConfigurationLogicRequest.SurchargeEnum",
    "UpdateSplitConfigurationLogicRequest.TipEnum",
    "UpdateStoreRequest.StatusEnum",
    "Webhook.CommunicationFormatEnum",
    "Webhook.EncryptionProtocolEnum",
    "Webhook.FilterMerchantAccountTypeEnum",
    "Webhook.NetworkTypeEnum",
]);
let typeMap = {
    "AccelInfo": accelInfo_1.AccelInfo,
    "AdditionalCommission": additionalCommission_1.AdditionalCommission,
    "AdditionalSettings": additionalSettings_1.AdditionalSettings,
    "AdditionalSettingsResponse": additionalSettingsResponse_1.AdditionalSettingsResponse,
    "Address": address_1.Address,
    "AffirmInfo": affirmInfo_1.AffirmInfo,
    "AfterpayTouchInfo": afterpayTouchInfo_1.AfterpayTouchInfo,
    "AlipayPlusInfo": alipayPlusInfo_1.AlipayPlusInfo,
    "AllowedOrigin": allowedOrigin_1.AllowedOrigin,
    "AllowedOriginsResponse": allowedOriginsResponse_1.AllowedOriginsResponse,
    "AmexInfo": amexInfo_1.AmexInfo,
    "Amount": amount_1.Amount,
    "AndroidApp": androidApp_1.AndroidApp,
    "AndroidAppError": androidAppError_1.AndroidAppError,
    "AndroidAppsResponse": androidAppsResponse_1.AndroidAppsResponse,
    "AndroidCertificate": androidCertificate_1.AndroidCertificate,
    "AndroidCertificatesResponse": androidCertificatesResponse_1.AndroidCertificatesResponse,
    "ApiCredential": apiCredential_1.ApiCredential,
    "ApiCredentialLinks": apiCredentialLinks_1.ApiCredentialLinks,
    "ApplePayInfo": applePayInfo_1.ApplePayInfo,
    "BcmcInfo": bcmcInfo_1.BcmcInfo,
    "BillingEntitiesResponse": billingEntitiesResponse_1.BillingEntitiesResponse,
    "BillingEntity": billingEntity_1.BillingEntity,
    "CardholderReceipt": cardholderReceipt_1.CardholderReceipt,
    "CartesBancairesInfo": cartesBancairesInfo_1.CartesBancairesInfo,
    "ClearpayInfo": clearpayInfo_1.ClearpayInfo,
    "Commission": commission_1.Commission,
    "Company": company_1.Company,
    "CompanyApiCredential": companyApiCredential_1.CompanyApiCredential,
    "CompanyLinks": companyLinks_1.CompanyLinks,
    "CompanyUser": companyUser_1.CompanyUser,
    "Configuration": configuration_1.Configuration,
    "Connectivity": connectivity_1.Connectivity,
    "Contact": contact_1.Contact,
    "CreateAllowedOriginRequest": createAllowedOriginRequest_1.CreateAllowedOriginRequest,
    "CreateApiCredentialResponse": createApiCredentialResponse_1.CreateApiCredentialResponse,
    "CreateCompanyApiCredentialRequest": createCompanyApiCredentialRequest_1.CreateCompanyApiCredentialRequest,
    "CreateCompanyApiCredentialResponse": createCompanyApiCredentialResponse_1.CreateCompanyApiCredentialResponse,
    "CreateCompanyUserRequest": createCompanyUserRequest_1.CreateCompanyUserRequest,
    "CreateCompanyUserResponse": createCompanyUserResponse_1.CreateCompanyUserResponse,
    "CreateCompanyWebhookRequest": createCompanyWebhookRequest_1.CreateCompanyWebhookRequest,
    "CreateMerchantApiCredentialRequest": createMerchantApiCredentialRequest_1.CreateMerchantApiCredentialRequest,
    "CreateMerchantRequest": createMerchantRequest_1.CreateMerchantRequest,
    "CreateMerchantResponse": createMerchantResponse_1.CreateMerchantResponse,
    "CreateMerchantUserRequest": createMerchantUserRequest_1.CreateMerchantUserRequest,
    "CreateMerchantWebhookRequest": createMerchantWebhookRequest_1.CreateMerchantWebhookRequest,
    "CreateUserResponse": createUserResponse_1.CreateUserResponse,
    "Currency": currency_1.Currency,
    "CustomNotification": customNotification_1.CustomNotification,
    "DataCenter": dataCenter_1.DataCenter,
    "DinersInfo": dinersInfo_1.DinersInfo,
    "EventUrl": eventUrl_1.EventUrl,
    "ExternalTerminalAction": externalTerminalAction_1.ExternalTerminalAction,
    "GenerateApiKeyResponse": generateApiKeyResponse_1.GenerateApiKeyResponse,
    "GenerateClientKeyResponse": generateClientKeyResponse_1.GenerateClientKeyResponse,
    "GenerateHmacKeyResponse": generateHmacKeyResponse_1.GenerateHmacKeyResponse,
    "GenericPmWithTdiInfo": genericPmWithTdiInfo_1.GenericPmWithTdiInfo,
    "GooglePayInfo": googlePayInfo_1.GooglePayInfo,
    "Gratuity": gratuity_1.Gratuity,
    "Hardware": hardware_1.Hardware,
    "IdName": idName_1.IdName,
    "InstallAndroidAppDetails": installAndroidAppDetails_1.InstallAndroidAppDetails,
    "InstallAndroidCertificateDetails": installAndroidCertificateDetails_1.InstallAndroidCertificateDetails,
    "InvalidField": invalidField_1.InvalidField,
    "JCBInfo": jCBInfo_1.JCBInfo,
    "Key": key_1.Key,
    "KlarnaInfo": klarnaInfo_1.KlarnaInfo,
    "Links": links_1.Links,
    "LinksElement": linksElement_1.LinksElement,
    "ListCompanyApiCredentialsResponse": listCompanyApiCredentialsResponse_1.ListCompanyApiCredentialsResponse,
    "ListCompanyResponse": listCompanyResponse_1.ListCompanyResponse,
    "ListCompanyUsersResponse": listCompanyUsersResponse_1.ListCompanyUsersResponse,
    "ListExternalTerminalActionsResponse": listExternalTerminalActionsResponse_1.ListExternalTerminalActionsResponse,
    "ListMerchantApiCredentialsResponse": listMerchantApiCredentialsResponse_1.ListMerchantApiCredentialsResponse,
    "ListMerchantResponse": listMerchantResponse_1.ListMerchantResponse,
    "ListMerchantUsersResponse": listMerchantUsersResponse_1.ListMerchantUsersResponse,
    "ListStoresResponse": listStoresResponse_1.ListStoresResponse,
    "ListTerminalsResponse": listTerminalsResponse_1.ListTerminalsResponse,
    "ListWebhooksResponse": listWebhooksResponse_1.ListWebhooksResponse,
    "Localization": localization_1.Localization,
    "Logo": logo_1.Logo,
    "MeApiCredential": meApiCredential_1.MeApiCredential,
    "MealVoucherFRInfo": mealVoucherFRInfo_1.MealVoucherFRInfo,
    "Merchant": merchant_1.Merchant,
    "MerchantLinks": merchantLinks_1.MerchantLinks,
    "MinorUnitsMonetaryValue": minorUnitsMonetaryValue_1.MinorUnitsMonetaryValue,
    "ModelFile": modelFile_1.ModelFile,
    "Name": name_1.Name,
    "Name2": name2_1.Name2,
    "Nexo": nexo_1.Nexo,
    "Notification": notification_1.Notification,
    "NotificationUrl": notificationUrl_1.NotificationUrl,
    "NyceInfo": nyceInfo_1.NyceInfo,
    "OfflineProcessing": offlineProcessing_1.OfflineProcessing,
    "Opi": opi_1.Opi,
    "OrderItem": orderItem_1.OrderItem,
    "PaginationLinks": paginationLinks_1.PaginationLinks,
    "Passcodes": passcodes_1.Passcodes,
    "PayAtTable": payAtTable_1.PayAtTable,
    "PayByBankPlaidInfo": payByBankPlaidInfo_1.PayByBankPlaidInfo,
    "PayMeInfo": payMeInfo_1.PayMeInfo,
    "PayPalInfo": payPalInfo_1.PayPalInfo,
    "PayToInfo": payToInfo_1.PayToInfo,
    "Payment": payment_1.Payment,
    "PaymentMethod": paymentMethod_1.PaymentMethod,
    "PaymentMethodResponse": paymentMethodResponse_1.PaymentMethodResponse,
    "PaymentMethodSetupInfo": paymentMethodSetupInfo_1.PaymentMethodSetupInfo,
    "PayoutSettings": payoutSettings_1.PayoutSettings,
    "PayoutSettingsRequest": payoutSettingsRequest_1.PayoutSettingsRequest,
    "PayoutSettingsResponse": payoutSettingsResponse_1.PayoutSettingsResponse,
    "Profile": profile_1.Profile,
    "PulseInfo": pulseInfo_1.PulseInfo,
    "ReceiptOptions": receiptOptions_1.ReceiptOptions,
    "ReceiptPrinting": receiptPrinting_1.ReceiptPrinting,
    "Referenced": referenced_1.Referenced,
    "Refunds": refunds_1.Refunds,
    "ReleaseUpdateDetails": releaseUpdateDetails_1.ReleaseUpdateDetails,
    "ReprocessAndroidAppResponse": reprocessAndroidAppResponse_1.ReprocessAndroidAppResponse,
    "RequestActivationResponse": requestActivationResponse_1.RequestActivationResponse,
    "RestServiceError": restServiceError_1.RestServiceError,
    "ScheduleTerminalActionsRequest": scheduleTerminalActionsRequest_1.ScheduleTerminalActionsRequest,
    "ScheduleTerminalActionsRequestActionDetails": scheduleTerminalActionsRequestActionDetails_1.ScheduleTerminalActionsRequestActionDetailsClass,
    "ScheduleTerminalActionsResponse": scheduleTerminalActionsResponse_1.ScheduleTerminalActionsResponse,
    "SepaDirectDebitInfo": sepaDirectDebitInfo_1.SepaDirectDebitInfo,
    "Settings": settings_1.Settings,
    "ShippingLocation": shippingLocation_1.ShippingLocation,
    "ShippingLocationsResponse": shippingLocationsResponse_1.ShippingLocationsResponse,
    "Signature": signature_1.Signature,
    "SodexoInfo": sodexoInfo_1.SodexoInfo,
    "SofortInfo": sofortInfo_1.SofortInfo,
    "SplitConfiguration": splitConfiguration_1.SplitConfiguration,
    "SplitConfigurationList": splitConfigurationList_1.SplitConfigurationList,
    "SplitConfigurationLogic": splitConfigurationLogic_1.SplitConfigurationLogic,
    "SplitConfigurationRule": splitConfigurationRule_1.SplitConfigurationRule,
    "Standalone": standalone_1.Standalone,
    "StarInfo": starInfo_1.StarInfo,
    "Store": store_1.Store,
    "StoreAndForward": storeAndForward_1.StoreAndForward,
    "StoreCreationRequest": storeCreationRequest_1.StoreCreationRequest,
    "StoreCreationWithMerchantCodeRequest": storeCreationWithMerchantCodeRequest_1.StoreCreationWithMerchantCodeRequest,
    "StoreLocation": storeLocation_1.StoreLocation,
    "StoreSplitConfiguration": storeSplitConfiguration_1.StoreSplitConfiguration,
    "SubMerchantData": subMerchantData_1.SubMerchantData,
    "SupportedCardTypes": supportedCardTypes_1.SupportedCardTypes,
    "Surcharge": surcharge_1.Surcharge,
    "SwishInfo": swishInfo_1.SwishInfo,
    "TapToPay": tapToPay_1.TapToPay,
    "Terminal": terminal_1.Terminal,
    "TerminalActionScheduleDetail": terminalActionScheduleDetail_1.TerminalActionScheduleDetail,
    "TerminalAssignment": terminalAssignment_1.TerminalAssignment,
    "TerminalConnectivity": terminalConnectivity_1.TerminalConnectivity,
    "TerminalConnectivityBluetooth": terminalConnectivityBluetooth_1.TerminalConnectivityBluetooth,
    "TerminalConnectivityCellular": terminalConnectivityCellular_1.TerminalConnectivityCellular,
    "TerminalConnectivityEthernet": terminalConnectivityEthernet_1.TerminalConnectivityEthernet,
    "TerminalConnectivityWifi": terminalConnectivityWifi_1.TerminalConnectivityWifi,
    "TerminalInstructions": terminalInstructions_1.TerminalInstructions,
    "TerminalModelsResponse": terminalModelsResponse_1.TerminalModelsResponse,
    "TerminalOrder": terminalOrder_1.TerminalOrder,
    "TerminalOrderRequest": terminalOrderRequest_1.TerminalOrderRequest,
    "TerminalOrdersResponse": terminalOrdersResponse_1.TerminalOrdersResponse,
    "TerminalProduct": terminalProduct_1.TerminalProduct,
    "TerminalProductPrice": terminalProductPrice_1.TerminalProductPrice,
    "TerminalProductsResponse": terminalProductsResponse_1.TerminalProductsResponse,
    "TerminalReassignmentRequest": terminalReassignmentRequest_1.TerminalReassignmentRequest,
    "TerminalReassignmentTarget": terminalReassignmentTarget_1.TerminalReassignmentTarget,
    "TerminalSettings": terminalSettings_1.TerminalSettings,
    "TestCompanyWebhookRequest": testCompanyWebhookRequest_1.TestCompanyWebhookRequest,
    "TestOutput": testOutput_1.TestOutput,
    "TestWebhookRequest": testWebhookRequest_1.TestWebhookRequest,
    "TestWebhookResponse": testWebhookResponse_1.TestWebhookResponse,
    "TicketInfo": ticketInfo_1.TicketInfo,
    "Timeouts": timeouts_1.Timeouts,
    "TransactionDescriptionInfo": transactionDescriptionInfo_1.TransactionDescriptionInfo,
    "TwintInfo": twintInfo_1.TwintInfo,
    "UninstallAndroidAppDetails": uninstallAndroidAppDetails_1.UninstallAndroidAppDetails,
    "UninstallAndroidCertificateDetails": uninstallAndroidCertificateDetails_1.UninstallAndroidCertificateDetails,
    "UpdatableAddress": updatableAddress_1.UpdatableAddress,
    "UpdateCompanyApiCredentialRequest": updateCompanyApiCredentialRequest_1.UpdateCompanyApiCredentialRequest,
    "UpdateCompanyUserRequest": updateCompanyUserRequest_1.UpdateCompanyUserRequest,
    "UpdateCompanyWebhookRequest": updateCompanyWebhookRequest_1.UpdateCompanyWebhookRequest,
    "UpdateMerchantApiCredentialRequest": updateMerchantApiCredentialRequest_1.UpdateMerchantApiCredentialRequest,
    "UpdateMerchantUserRequest": updateMerchantUserRequest_1.UpdateMerchantUserRequest,
    "UpdateMerchantWebhookRequest": updateMerchantWebhookRequest_1.UpdateMerchantWebhookRequest,
    "UpdatePaymentMethodInfo": updatePaymentMethodInfo_1.UpdatePaymentMethodInfo,
    "UpdatePayoutSettingsRequest": updatePayoutSettingsRequest_1.UpdatePayoutSettingsRequest,
    "UpdateSplitConfigurationLogicRequest": updateSplitConfigurationLogicRequest_1.UpdateSplitConfigurationLogicRequest,
    "UpdateSplitConfigurationRequest": updateSplitConfigurationRequest_1.UpdateSplitConfigurationRequest,
    "UpdateSplitConfigurationRuleRequest": updateSplitConfigurationRuleRequest_1.UpdateSplitConfigurationRuleRequest,
    "UpdateStoreRequest": updateStoreRequest_1.UpdateStoreRequest,
    "UploadAndroidAppResponse": uploadAndroidAppResponse_1.UploadAndroidAppResponse,
    "UploadAndroidCertificateResponse": uploadAndroidCertificateResponse_1.UploadAndroidCertificateResponse,
    "Url": url_1.Url,
    "User": user_1.User,
    "VippsInfo": vippsInfo_1.VippsInfo,
    "WeChatPayInfo": weChatPayInfo_1.WeChatPayInfo,
    "WeChatPayPosInfo": weChatPayPosInfo_1.WeChatPayPosInfo,
    "Webhook": webhook_1.Webhook,
    "WebhookLinks": webhookLinks_1.WebhookLinks,
    "WifiProfiles": wifiProfiles_1.WifiProfiles,
};
/**
 * Every mime-type consists of a type, subtype, and optional parameters.
 * The subtype can be composite, including information about the content format.
 * For example: `application/json-patch+json`, `application/merge-patch+json`.
 *
 * This helper transforms a string mime-type into an internal representation.
 * This simplifies the implementation of predicates that in turn define common rules for parsing or stringifying
 * the payload.
 */
const parseMimeType = (mimeType) => {
    const [type = '', subtype = ''] = mimeType.split('/');
    return {
        type,
        subtype,
        subtypeTokens: subtype.split('+'),
    };
};
// This factory creates a predicate function that checks a string mime-type against defined rules.
const mimeTypePredicateFactory = (predicate) => (mimeType) => predicate(parseMimeType(mimeType));
// Use this factory when you need to define a simple predicate based only on type and, if applicable, subtype.
const mimeTypeSimplePredicateFactory = (type, subtype) => mimeTypePredicateFactory((descriptor) => {
    if (descriptor.type !== type)
        return false;
    if (subtype != null && descriptor.subtype !== subtype)
        return false;
    return true;
});
// Creating a set of named predicates that will help us determine how to handle different mime-types
const isTextLikeMimeType = mimeTypeSimplePredicateFactory('text');
const isJsonMimeType = mimeTypeSimplePredicateFactory('application', 'json');
const isJsonLikeMimeType = mimeTypePredicateFactory((descriptor) => descriptor.type === 'application' && descriptor.subtypeTokens.some((item) => item === 'json'));
const isOctetStreamMimeType = mimeTypeSimplePredicateFactory('application', 'octet-stream');
const isFormUrlencodedMimeType = mimeTypeSimplePredicateFactory('application', 'x-www-form-urlencoded');
// Defining a list of mime-types in the order of prioritization for handling.
const supportedMimeTypePredicatesWithPriority = [
    isJsonMimeType,
    isJsonLikeMimeType,
    isTextLikeMimeType,
    isOctetStreamMimeType,
    isFormUrlencodedMimeType,
];
const nullableSuffix = " | null";
const optionalSuffix = " | undefined";
const arrayPrefix = "Array<";
const arraySuffix = ">";
const mapPrefix = "{ [key: string]: ";
const mapSuffix = "; }";
class ObjectSerializer {
    static findCorrectType(data, expectedType) {
        if (data == undefined) {
            return expectedType;
        }
        else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        }
        else if (expectedType === "Date") {
            return expectedType;
        }
        else {
            if (enumsMap.has(expectedType)) {
                return expectedType;
            }
            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }
            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            }
            else {
                if (data[discriminatorProperty]) {
                    var discriminatorType = data[discriminatorProperty];
                    let mapping = typeMap[expectedType].mapping;
                    if (mapping != undefined && mapping[discriminatorType]) {
                        return mapping[discriminatorType]; // use the type given in the discriminator
                    }
                    else if (typeMap[discriminatorType]) {
                        return discriminatorType;
                    }
                    else {
                        return expectedType; // discriminator did not map to a type
                    }
                }
                else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }
    /**
     * Serializes a value into a plain JSON-compatible object based on its type.
     *
     * Supports primitives, arrays, maps, dates, enums, and classes defined in `typeMap`.
     * Falls back to raw data if type is unknown or lacks `getAttributeTypeMap()`.
     *
     * @param data - The value to serialize.
     * @param type - The expected type name as a string.
     * @param format - Format hint (e.g. "date" or "date-time"). Default is an empty string.
     * @returns A JSON-compatible representation of `data`.
     */
    static serialize(data, type, format = "") {
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.endsWith(nullableSuffix)) {
            let subType = type.slice(0, -nullableSuffix.length); // Type | null => Type
            return ObjectSerializer.serialize(data, subType, format);
        }
        else if (type.endsWith(optionalSuffix)) {
            let subType = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
            return ObjectSerializer.serialize(data, subType, format);
        }
        else if (type.startsWith(arrayPrefix)) {
            let subType = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
            let transformedData = [];
            for (let date of data) {
                transformedData.push(ObjectSerializer.serialize(date, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(mapPrefix)) {
            let subType = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
            let transformedData = {};
            for (let key in data) {
                transformedData[key] = ObjectSerializer.serialize(data[key], subType, format);
            }
            return transformedData;
        }
        else if (type === "Date") {
            if (format == "date") {
                let month = data.getMonth() + 1;
                month = month < 10 ? "0" + month.toString() : month.toString();
                let day = data.getDate();
                day = day < 10 ? "0" + day.toString() : day.toString();
                return data.getFullYear() + "-" + month + "-" + day;
            }
            else {
                return data.toISOString();
            }
        }
        else {
            if (enumsMap.has(type)) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }
            // Get the actual type of this object
            type = this.findCorrectType(data, type);
            const clazz = typeMap[type];
            // Safe check for getAttributeTypeMap
            if (typeof clazz.getAttributeTypeMap !== "function") {
                return { ...data }; // fallback: shallow copy
            }
            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let attributeType of attributeTypes) {
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }
    /**
     * Deserializes a plain JSON-compatible object into a typed instance.
     *
     * Handles primitives, arrays, maps, dates, enums, and known classes from `typeMap`.
     * Uses discriminators when available to resolve polymorphic types.
     * Falls back to raw data if the type is unknown or lacks `getAttributeTypeMap()`.
     *
     * @param data - The raw input to deserialize.
     * @param type - The expected type name as a string.
     * @param format - Format hint (e.g. "date" or "date-time"). Default is an empty string.
     * @returns A deserialized instance or value of `data`.
     */
    static deserialize(data, type, format = "") {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        }
        else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        }
        else if (type.endsWith(nullableSuffix)) {
            let subType = type.slice(0, -nullableSuffix.length); // Type | null => Type
            return ObjectSerializer.deserialize(data, subType, format);
        }
        else if (type.endsWith(optionalSuffix)) {
            let subType = type.slice(0, -optionalSuffix.length); // Type | undefined => Type
            return ObjectSerializer.deserialize(data, subType, format);
        }
        else if (type.startsWith(arrayPrefix)) {
            let subType = type.slice(arrayPrefix.length, -arraySuffix.length); // Array<Type> => Type
            let transformedData = [];
            for (let date of data) {
                transformedData.push(ObjectSerializer.deserialize(date, subType, format));
            }
            return transformedData;
        }
        else if (type.startsWith(mapPrefix)) {
            let subType = type.slice(mapPrefix.length, -mapSuffix.length); // { [key: string]: Type; } => Type
            let transformedData = {};
            for (let key in data) {
                transformedData[key] = ObjectSerializer.deserialize(data[key], subType, format);
            }
            return transformedData;
        }
        else if (type === "Date") {
            return new Date(data);
        }
        else {
            if (enumsMap.has(type)) { // is Enum
                return data;
            }
            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            // Safe check for getAttributeTypeMap
            if (typeof typeMap[type].getAttributeTypeMap !== "function") {
                Object.assign(instance, data); // fallback: shallow copy
                return instance;
            }
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let attributeType of attributeTypes) {
                let value = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
                if (value !== undefined) {
                    instance[attributeType.name] = value;
                }
            }
            return instance;
        }
    }
    /**
     * Normalize media type
     *
     * We currently do not handle any media types attributes, i.e. anything
     * after a semicolon. All content is assumed to be UTF-8 compatible.
     */
    static normalizeMediaType(mediaType) {
        var _a;
        if (mediaType === undefined) {
            return undefined;
        }
        return ((_a = mediaType.split(";")[0]) !== null && _a !== void 0 ? _a : '').trim().toLowerCase();
    }
    /**
     * From a list of possible media types, choose the one we can handle best.
     *
     * The order of the given media types does not have any impact on the choice
     * made.
     */
    static getPreferredMediaType(mediaTypes) {
        /** According to OAS 3 we should default to json */
        if (mediaTypes.length === 0) {
            return "application/json";
        }
        const normalMediaTypes = mediaTypes.map(ObjectSerializer.normalizeMediaType);
        for (const predicate of supportedMimeTypePredicatesWithPriority) {
            for (const mediaType of normalMediaTypes) {
                if (mediaType != null && predicate(mediaType)) {
                    return mediaType;
                }
            }
        }
        throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
    }
    /**
     * Convert data to a string according the given media type
     */
    static stringify(data, mediaType) {
        if (isTextLikeMimeType(mediaType)) {
            return String(data);
        }
        if (isJsonLikeMimeType(mediaType)) {
            return JSON.stringify(data);
        }
        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.stringify.");
    }
    /**
     * Parse data from a string according to the given media type
     */
    static parse(rawData, mediaType) {
        if (mediaType === undefined) {
            throw new Error("Cannot parse content. No Content-Type defined.");
        }
        if (isTextLikeMimeType(mediaType)) {
            return rawData;
        }
        if (isJsonLikeMimeType(mediaType)) {
            return JSON.parse(rawData);
        }
        throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.parse.");
    }
}
exports.ObjectSerializer = ObjectSerializer;
//# sourceMappingURL=objectSerializer.js.map